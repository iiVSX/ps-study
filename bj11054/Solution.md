<pre>
Algorithm : LIS & DP
Problem : i번째 수에 대해서 0~i까지는 증가하고, i~N까지는 감소하는 부분수열의 합의 최대 길이를 구하여라
Idea : 
  초기 아이디어: i번쨰 수에 대해서 0~i-1까지의 수 중 자신보다 작은 수가 가지는 증가수열 dp_max[i]의 값이 가장 큰 것의 값 + 1, i+1~N까지의 수 중 자신보다 작은 수가 가지는 감소수열 dp_min[i]의 값이 가장 큰 것의 값 + 1
  문제점 : 시간 초과, 0~N까지 각 수 i에 대해서 자신보다 작은 수 중 최대 증가 수열의 길이를 구하는 것은 O(N^2)이다.
  해결점 : Longest Increasing Sequence 알고리즘을 응용하도록한다. 0~N까지 순회하면서, i번째 수 A[i]에 대해서 0~i-1까지의 최대 증가수열의 길이 k를 기록하는 배열 D를 D[k] = min(D[k], A[i])라고하자.
          그렇다면, 분할 정복을 통해서 D배열 내에서 A[i]가 배치되어야 하는 위치를 O(logN)만에 구할 수 있을 것이다. 
  
          분할 정복 함수를 divAndConquer(A[i], D, left, right)로 정의한다. mid = (left+right)/2로 정의하고 D[mid]보다 A[i]가 클 경우, divAndConquer(A[i], D, mid+1, right)를 이외에는
          divAndConquer(A[i], D, left, mid)를 재귀적으로 호출하고 탈출조건으로는 left가 right보다 크거나 같을 때 left를 반환한다.
          반환한 index를 조사하여 D[index]가 A[i]보다 작을 경우 index를 증가시키고 index가 D의 길이보다 길 경우 D의 길이를 증가시킨다. 
          이외의 경우 D[index]가 A[i]보다 클 경우, 같은 길이 k에 대해서 작은 수를 기록하는 것이 최대 길이를 기록하는데 유리하므로 갱신해주도록 한다.

          위 과정을 통해 0~i까지의 수 중에 가장 긴 증가하는 부분 수열의 길이를 구할 수 있을 것이다. 반면, i~N까지의 감소하는 부분 수열의 길이는 발상을 전환하여 N부터 시작하여 0까지 기록하면서 같은 과정을 반복한다면 구할 수 있을 것이다.
</pre>
